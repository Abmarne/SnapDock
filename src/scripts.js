/* SnapDock - A simple markdown editor and viewer
   Core script: scripts.js
*/
const MarkdownIt = window.markdownit;

function debounce(func, timeout = 300) {
    let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => func.apply(this, args), timeout);
    };
}

/* DOM cache */

const $ = id => document.getElementById(id);

const themeToggleBtn = $('themeToggleBtn');
const openFileBtn = $('openFileBtn');
const exportPdfBtn = $('exportPdfBtn');
const markdownEditor = $('markdownEditor');
const previewPane = $('previewPane');
const toggleViewBtn = $('toggleViewBtn');
const editorContainer = $('editorContainer');
// Toggle view mode
toggleViewBtn.addEventListener('click', () => {
    const isPreviewMode = editorContainer.classList.contains('preview-mode');
    editorContainer.classList.remove('preview-mode', 'edit-mode');
    const newMode = isPreviewMode ? 'edit-mode' : 'preview-mode';
    editorContainer.classList.add(newMode);
    toggleViewBtn.classList.remove('preview-mode', 'edit-mode');
    toggleViewBtn.classList.add(newMode);

    // If we're switching to edit mode, focus the textarea so the user can type immediately
    if (newMode === 'edit-mode') {
        markdownEditor.focus();
        // place cursor at end
        const len = markdownEditor.value.length;
        markdownEditor.setSelectionRange(len, len);
    }
});

// Start in edit mode so the main window is writable by default
window.addEventListener('DOMContentLoaded', () => {
    // Defensive checks in case elements aren't present
    if (editorContainer && toggleViewBtn) {
        editorContainer.classList.add('edit-mode');
        toggleViewBtn.classList.add('edit-mode');
        // focus editor on load
        markdownEditor.focus();
    }
});
const saveFileBtn = $('saveFileBtn');
const filenameDisplay = $('filenameDisplay');
const filenameInput = $('filenameInput');
const versionTag = $('versionTag');
const fileList = $('fileList');
const tabs = $('tabs');
const openFolderBtn = $('openFolderBtn');
const folderTree = $('folderTree');
const helpBtn = $('helpBtn');
const updateBtn = $('updateBtn');
const newFileBtn = $('newFileBtn');

/*  Utility helpers */

function setLS(key, val) {
    localStorage.setItem(key, JSON.stringify(val));
}
function getLS(key, def = null) {
    try { return JSON.parse(localStorage.getItem(key)); } catch (_) { }
    return def;
}
function triggerDownload(name, content, mime = 'text/plain') {
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = name; a.click();
    URL.revokeObjectURL(url);
}
// Initialize markdown-it with all available features
const md = new MarkdownIt({
    html: true,
    xhtmlOut: true,
    breaks: true,
    linkify: true,
    typographer: true,
    langPrefix: 'language-',
    quotes: '\u201c\u201d\u2018\u2019',
    maxNesting: 100,
    highlight: function (str, lang) {
        if (lang && lang !== 'plain') {
            return '<pre class="highlight"><code class="language-' + lang + '">' +
                str +
                '</code></pre>';
        }
        return '<pre class="highlight"><code>' + str + '</code></pre>';
    }
});

// Enable all available rules
md.enable('code')
    .enable('fence')
    .enable('table')
    .enable('heading')
    .enable('lheading')
    .enable('hr')
    .enable('list')
    .enable('reference')
    .enable('blockquote')
    .enable('html_block')
    .enable('paragraph')
    .enable('link')
    .enable('image')
    .enable('emphasis')
    .enable('autolink')
    .enable('backticks')
    .enable('strikethrough')
    .enable('html_inline');

function renderMarkdown(text) {
    previewPane.innerHTML = md.render(text);
}

/* Theme handling */

const THEME_KEY = 'snapdock-theme';
themeToggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    setLS(THEME_KEY, document.body.classList.contains('dark-mode') ? 'dark' : 'light');
});
window.addEventListener('DOMContentLoaded', () => {
    if (getLS(THEME_KEY, 'light') === 'dark')
        document.body.classList.add('dark-mode');
});
/* File operations */

const AUTOSAVE_KEY = 'snapdock-autosave';
const RECENT_KEY = 'snapdock-recent';

function pickFile(accept, callback) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = accept;
    input.onchange = e => {
        const f = e.target.files[0];
        if (!f) return;
        const r = new FileReader();
        r.onload = ev => callback(ev.target.result, f.name);
        r.readAsText(f);
    };
    input.click();
}
function pickFolder(callback) {
    const input = document.createElement('input');
    input.type = 'file';
    input.webkitdirectory = true;
    input.multiple = true;
    input.accept = '.md';
    input.onchange = e => {
        const files = Array.from(e.target.files).filter(f => f.name.endsWith('.md'));
        callback(files);
    };
    input.click();
}
function loadContent(name, text) {
    markdownEditor.value = text;
    renderMarkdown(text);
    filenameDisplay.textContent = name;
    filenameInput.value = name;

    setLS(AUTOSAVE_KEY, text);
    saveToRecentFiles(name, text);
}
function saveCurrentFile(useFilename) {
    const name = useFilename ? filenameInput.value.trim() || 'untitled.md'
        : `snapdock-${Date.now()}.md`;
    triggerDownload(name, markdownEditor.value, 'text/markdown');
}

/*  Autosave â€“ debounced listener */

const debouncedRender = debounce(() => {
    renderMarkdown(markdownEditor.value);
    setLS(AUTOSAVE_KEY, markdownEditor.value);
}, 300);

markdownEditor.addEventListener('input', debouncedRender);

/* Load autosaved content on startup */
window.addEventListener('DOMContentLoaded', () => {
    const saved = getLS(AUTOSAVE_KEY, '');
    if (saved) loadContent(filenameInput.value || 'untitled.md', saved);
});

/* Manual save button */
saveFileBtn.addEventListener('click', () => saveCurrentFile(true));

/* New file button â€“ clears the editor and creates a unique untitled name */
newFileBtn.addEventListener('click', () => {
    const name = `untitled-${Date.now()}.md`;
    markdownEditor.value = '';
    previewPane.innerHTML = '';
    loadContent(name, '');
});


/*  Filename editing UI */

filenameDisplay.addEventListener('click', () => {
    filenameDisplay.style.display = 'none';
    filenameInput.style.display = 'inline-block';
    filenameInput.focus();
});
filenameInput.addEventListener('blur', () => {
    const newName = filenameInput.value.trim() || 'untitled.md';
    loadContent(newName, markdownEditor.value);
});

/*  Recent files & sidebar */
function renderRecentFiles(files) {
    fileList.innerHTML = '';
    files.forEach(f => {
        const li = document.createElement('li');
        li.textContent = f.name;
        li.addEventListener('click', () => openFileInTab(f.name, f.content));
        fileList.appendChild(li);
    });
}
function saveToRecentFiles(name, content) {
    const recent = getLS(RECENT_KEY, []);
    const updated = [{ name, content }, ...recent.filter(r => r.name !== name)].slice(0, 10);
    setLS(RECENT_KEY, updated);
    renderRecentFiles(updated);
}
/* Load recent files on startup */
window.addEventListener('DOMContentLoaded', () => {
    const recent = getLS(RECENT_KEY, []);
    renderRecentFiles(recent);
});


/* Tab system */

let openTabs = {}; // Object to store file content by tab name

function openFileInTab(name, content) {
    let existing = document.querySelector(`.tab[data-name="${name}"]`);
    if (existing) return setActiveTab(existing);

    const tab = document.createElement('div');
    tab.className = 'tab';
    tab.dataset.name = name;
    tab.innerHTML = `${name}<span class="closeTab">Ã—</span>`;
    tab.addEventListener('click', () => setActiveTab(tab));
    tabs.appendChild(tab);
    setActiveTab(tab);

    openTabs[name] = content; // Store the content in openTabs

    if (name === 'user_guide.md') {
        loadContent(name, content); // Load help content into editor
    } else {
        openFileInEditor(content); // Open other files normally
    }
}

function setActiveTab(tab) {
    const name = tab.dataset.name;
    const content = openTabs[name];
    if (content) {
        markdownEditor.value = content;
        renderMarkdown(content);
    }

    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
}

tabs.addEventListener('click', e => {
    if (e.target.classList.contains('closeTab')) {
        const tab = e.target.parentElement;
        const name = tab.dataset.name;
        tab.remove();
        delete openTabs[name]; // Remove the content from openTabs

        const remaining = tabs.querySelector('.tab');
        if (remaining) setActiveTab(remaining);
    }
});

function openFileInEditor(content) {
    const filename = `untitled-${Date.now()}.md`;
    loadContent(filename, content);
}

/*  Folder tree handling */

function buildFolderTree(files) {
    const root = {};
    files.forEach(file => {
        const parts = file.webkitRelativePath.split('/');
        let node = root;
        parts.forEach((p, i) => {
            if (i === parts.length - 1) { node[p] = file; }
            else { node[p] = node[p] || {}; node = node[p]; }
        });
    });
    return root;
}
function renderFolderTree(tree, parent = folderTree) {
    parent.innerHTML = '';
    Object.entries(tree).forEach(([name, val]) => {
        const li = document.createElement('li');
        if (val instanceof File) {
            li.className = 'file';
            li.textContent = `ðŸ“„ ${name}`;
            li.addEventListener('click', () => {
                const r = new FileReader();
                r.onload = e => openFileInTab(name, e.target.result);
                r.readAsText(val);
            });
        } else {
            li.className = 'folder';
            const label = document.createElement('span');
            label.textContent = `ðŸ“ ${name}`;
            label.style.cursor = 'pointer';

            const sub = document.createElement('ul');
            sub.style.display = 'none'; // collapsed

            label.addEventListener('click', () => {
                sub.style.display = sub.style.display === 'none' ? 'block' : 'none';
            });

            li.appendChild(label);
            renderFolderTree(val, sub);
            li.appendChild(sub);
        }
        parent.appendChild(li);
    });
}
openFolderBtn.addEventListener('click', () => pickFolder(files => renderFolderTree(buildFolderTree(files))));
document.body.addEventListener('dragover', e => e.preventDefault());
document.body.addEventListener('drop', async e => {
    e.preventDefault();
    const items = Array.from(e.dataTransfer.items);
    const files = [];
    for (const item of items) {
        const entry = item.webkitGetAsEntry();
        if (entry) await traverseFileTree(entry, '', files);
    }
    renderFolderTree(buildFolderTree(files));
});
function traverseFileTree(entry, path, out) {
    return new Promise(resolve => {
        if (entry.isFile) {
            entry.file(f => { f.webkitRelativePath = path + f.name; if (f.name.endsWith('.md')) out.push(f); resolve(); });
        } else if (entry.isDirectory) {
            const reader = entry.createReader();
            reader.readEntries(ents => {
                let pending = ents.length;
                if (!pending) return resolve();
                ents.forEach(e => traverseFileTree(e, path + entry.name + '/', out).then(() => { if (--pending === 0) resolve(); }));
            });
        }
    });
}


/* Open file / folder via button (single & multi) */

openFileBtn.addEventListener('click', () => pickFile('.md,.txt', (text, name) => openFileInTab(name, text)));
pickFolder(files => files.forEach(f => {
    const r = new FileReader();
    r.onload = e => openFileInTab(f.name, e.target.result);
    r.readAsText(f);
}));

/* Help & Update dialogs */

function showHelp() {
    fetch('assets/resources/docs/user_guide.md')
        .then(response => response.text())
        .then(text => {
            // Open the fetched markdown content into a new tab
            openFileInTab('user_guide.md', text);
        })
        .catch(error => console.error('Error fetching help documentation:', error));
}

helpBtn.addEventListener('click', showHelp);

updateBtn.addEventListener('click', () => {
    fetch('version.json')
        .then(r => r.json())
        .then(d => alert(`SnapDock ${d.version} (${d.build})\nBuild date: ${d.date}`))
        .catch(() => alert('Unable to check for updates.'));
});

/* Version tag */

fetch('version.json')
    .then(r => r.json())
    .then(d => { versionTag.textContent = `v${d.version} ${d.build}`; })
    .catch(() => { versionTag.textContent = 'v2.0.0'; });


